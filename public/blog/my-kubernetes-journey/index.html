<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Kubernetes Journey: From kubectl to GitOps | Kyle Mapue</title>
<meta name="keywords" content="">
<meta name="description" content="Introduction
For anyone diving into DevOps, there&rsquo;s a moment when the theory of Kubernetes—all the talk of Pods, Services, and Deployments—needs to meet the messy reality of practice. My journey with the &ldquo;Log-Pong&rdquo; application was exactly that: a hands-on, often challenging, but ultimately rewarding experience that took me from manually managing resources to orchestrating a fully automated GitOps pipeline.
This post isn&rsquo;t just a project showcase. It&rsquo;s a story about the power of starting with the fundamentals, embracing the &ldquo;manual&rdquo; way to build deep understanding, and then leveraging that knowledge to build a professional, automated workflow. If you&rsquo;re on a similar path, I hope my story resonates and offers some useful insights.">
<meta name="author" content="Kyle Mapue">
<link rel="canonical" href="http://localhost:1313/blog/my-kubernetes-journey/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8943a90491e468f6ef8d33a5ef0a5845622d5178e663849217af60f670605c5b.css" integrity="sha256-iUOpBJHkaPbvjTOl7wpYRWItUXjmY4SSF69g9nBgXFs=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/images/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/blog/my-kubernetes-journey/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://localhost:1313/blog/my-kubernetes-journey/">
  <meta property="og:site_name" content="Kyle Mapue">
  <meta property="og:title" content="Kubernetes Journey: From kubectl to GitOps">
  <meta property="og:description" content="Introduction For anyone diving into DevOps, there’s a moment when the theory of Kubernetes—all the talk of Pods, Services, and Deployments—needs to meet the messy reality of practice. My journey with the “Log-Pong” application was exactly that: a hands-on, often challenging, but ultimately rewarding experience that took me from manually managing resources to orchestrating a fully automated GitOps pipeline.
This post isn’t just a project showcase. It’s a story about the power of starting with the fundamentals, embracing the “manual” way to build deep understanding, and then leveraging that knowledge to build a professional, automated workflow. If you’re on a similar path, I hope my story resonates and offers some useful insights.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2025-07-28T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-07-28T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kubernetes Journey: From kubectl to GitOps">
<meta name="twitter:description" content="Introduction
For anyone diving into DevOps, there&rsquo;s a moment when the theory of Kubernetes—all the talk of Pods, Services, and Deployments—needs to meet the messy reality of practice. My journey with the &ldquo;Log-Pong&rdquo; application was exactly that: a hands-on, often challenging, but ultimately rewarding experience that took me from manually managing resources to orchestrating a fully automated GitOps pipeline.
This post isn&rsquo;t just a project showcase. It&rsquo;s a story about the power of starting with the fundamentals, embracing the &ldquo;manual&rdquo; way to build deep understanding, and then leveraging that knowledge to build a professional, automated workflow. If you&rsquo;re on a similar path, I hope my story resonates and offers some useful insights.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "http://localhost:1313/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Kubernetes Journey: From kubectl to GitOps",
      "item": "http://localhost:1313/blog/my-kubernetes-journey/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kubernetes Journey: From kubectl to GitOps",
  "name": "Kubernetes Journey: From kubectl to GitOps",
  "description": "Introduction For anyone diving into DevOps, there\u0026rsquo;s a moment when the theory of Kubernetes—all the talk of Pods, Services, and Deployments—needs to meet the messy reality of practice. My journey with the \u0026ldquo;Log-Pong\u0026rdquo; application was exactly that: a hands-on, often challenging, but ultimately rewarding experience that took me from manually managing resources to orchestrating a fully automated GitOps pipeline.\nThis post isn\u0026rsquo;t just a project showcase. It\u0026rsquo;s a story about the power of starting with the fundamentals, embracing the \u0026ldquo;manual\u0026rdquo; way to build deep understanding, and then leveraging that knowledge to build a professional, automated workflow. If you\u0026rsquo;re on a similar path, I hope my story resonates and offers some useful insights.\n",
  "keywords": [
    
  ],
  "articleBody": "Introduction For anyone diving into DevOps, there’s a moment when the theory of Kubernetes—all the talk of Pods, Services, and Deployments—needs to meet the messy reality of practice. My journey with the “Log-Pong” application was exactly that: a hands-on, often challenging, but ultimately rewarding experience that took me from manually managing resources to orchestrating a fully automated GitOps pipeline.\nThis post isn’t just a project showcase. It’s a story about the power of starting with the fundamentals, embracing the “manual” way to build deep understanding, and then leveraging that knowledge to build a professional, automated workflow. If you’re on a similar path, I hope my story resonates and offers some useful insights.\nThe Log-Pong Application Before we dive into the how (the deployment), let’s quickly cover the what. The “Log-Pong” stack consists of two simple microservices designed to demonstrate key Kubernetes concepts:\nThe pingpong-app (The Backend):\nWhat it is: A stateful backend service. Technology: Node.js with the Koa framework, connected to a PostgreSQL database. What it does: Its only job is to expose an API endpoint (/ping). When called, it increments a counter in the database and returns the new number of “pongs.” This service represents a stateful component whose data must persist. The log-output-app (The Frontend/Aggregator):\nWhat it is: A frontend service that gathers information from various sources. Technology: Node.js with Koa, running in a unique two-container Pod. What it does: A writer container continuously writes the current timestamp to a shared file. A reader container waits for requests. When a request comes in, it reads the timestamp from the shared file, fetches a message from a Kubernetes ConfigMap, and makes an HTTP call to the pingpong-app to get the current pong count. It then combines all this information into a single string. How They Work Together: The user interacts with the log-output-app, which in turn communicates with the pingpong-app over the cluster’s internal network. The final output looks something like this:\nfile content: this text is from file env variable: MESSAGE=hello world 2025-07-21T10:30:00.123Z: a1b2c3d4e5f6... Ping / Pongs: 42 It’s a simple system, but its architecture is perfect for exploring the core concepts of Kubernetes networking, state management, and configuration. Now, let’s get into how it was deployed.\nManual Deployment Every project starts somewhere. Mine began with the two applications described above. Initially, getting them to run was a manual process of building Docker images and applying Kubernetes manifests one by one.\n# 1. Build the image docker build -t my-username/pingpong-app . # 2. Push it to a registry docker push my-username/pingpong-app # 3. Deploy it to the cluster kubectl apply -f manifests/deployment.yaml kubectl apply -f manifests/service.yaml I had to do this for both applications. It was tedious, but it was also the perfect way to learn the fundamentals. I wasn’t just running a script; I was forced to understand what each kubectl apply command was actually doing. What’s a Deployment? Why does it need a Service? How do labels and selectors work? This manual phase was my classroom.\nService Connectivity Running the apps was one thing; making them talk to each other was a whole new challenge. This is where the real learning began.\nMy first attempt involved the shared volume between the “writer” and “reader” containers, but the real breakthrough came when I truly understood Kubernetes Services. By giving my pingpong deployment a ClusterIP service, it received a stable DNS name inside the cluster.\nSuddenly, my log-output app could reliably find and talk to it over the network.\n// In the log-output reader's code const PINGPONG_URL = 'http://pingpong-svc:3001/ping'; // ... const pingResponse = await axios.get(PINGPONG_URL); const pingCount = pingResponse.data.pong; This was a huge “aha!” moment. I had moved from a shared-filesystem model to true service-to-service communication, the foundation of microservice architecture.\ngraph TD ExternalUser[External User] --\u003e KubernetesIngress(Kubernetes Ingress\\n(e.g., /log-output)) KubernetesIngress --\u003e ServiceLogOutput(Service: log-output\\n(Type: ClusterIP)) ServiceLogOutput --\u003e PodLogOutput(Pod: log-output\\n\\n - Reader Container\\n - Writer Container) ServiceLogOutput --\u003e ServicePingpong(Service: pingpong\\n(Type: ClusterIP)) PodLogOutput --\u003e ServicePingpong ServicePingpong --\u003e PodPingpong(Pod: pingpong\\n\\n - Koa App Container) It’s a simple system, but its architecture is perfect for exploring the core concepts of Kubernetes networking, state management, and configuration. Now, let’s get into how it was deployed.\nGitOps Automation The manual workflow had taught me a lot, but it was slow and error-prone. It was time to automate. I decided to refactor the entire project into a professional GitOps workflow using ArgoCD.\nThis meant a fundamental change in structure:\npingpong-code Repo: Contained only the application source code. log-output-code Repo: Contained only its application source code. log-pong-config Repo: Contained only the Kubernetes YAML manifests. This became my single source of truth. Next, I built a CI/CD pipeline with GitHub Actions for each application repository. On every push to main, the pipeline would:\nBuild a new Docker image and tag it with the commit SHA. Push the image to Docker Hub. Check out the log-pong-config repository. Automatically update the image: tag in the deployment manifest. Commit and push the change to the config repo. # A snippet from the GitHub Actions workflow - name: Update Image Tag run: | sed -i 's|image: .*|image: ${{ secrets.DOCKERHUB_USERNAME }}/pingpong-app:${{ github.sha }}|g' log-pong-config/manifests/rollout.yaml The final piece was ArgoCD. I pointed it at my log-pong-config repository. Now, whenever the CI pipeline pushed an updated image tag, ArgoCD would detect the change and automatically sync it with my cluster. My job was done. I had created a fully automated, end-to-end deployment pipeline.\nReliability Enhancements With the core workflow in place, I added two more features to make the system truly robust.\nReadiness Probes: The pingpong app is useless without its database. I configured a readinessProbe that hits a /healthz endpoint. This endpoint only returns a 200 OK if the database connection is active. Now, Kubernetes won’t send traffic to a pingpong pod until it’s confirmed it can do its job.\nTo prove this, I simulated a database failure by deleting its StatefulSet. When the pingpong pod tried to restart, it couldn’t connect. Running kubectl describe pod on the new pod revealed exactly what was happening in the events log:\nStatus: Running IP: 10.68.2.70 Ready: False ... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 15s scheduler Successfully assigned default/pingpong-rollout... Normal Pulled 15s kubelet Container image \"kylmps/pingpong:5\" already present... Normal Created 15s kubelet Created container pingpong Normal Started 15s kubelet Started container pingpong Warning Unhealthy 4s kubelet Readiness probe failed: HTTP probe failed with statuscode: 500 The probe was working perfectly, preventing the broken pod from receiving traffic and protecting the system from cascading failures.\nCanary Deployments \u0026 Automated Analysis: To deploy updates safely, I switched from a Deployment to an Argo Rollouts Rollout resource. I configured it to perform canary releases and defined an AnalysisTemplate to monitor CPU usage. If a new version causes a CPU spike, the rollout is automatically aborted and rolled back. No human intervention required.\nConclusion: The Journey is the Destination Building the Log-Pong stack taught me more than any tutorial ever could. By starting manually, I was forced to learn the “why” behind every Kubernetes object. That fundamental knowledge was the bedrock upon which I could confidently build a complex, automated GitOps workflow.\nIf you’re just starting out, embrace the manual steps. Break things. Fix them. Understand the moving parts. Because when you finally automate, you’ll be doing it with the confidence of someone who knows exactly what’s happening under the hood.\n",
  "wordCount" : "1229",
  "inLanguage": "en",
  "datePublished": "2025-07-28T00:00:00Z",
  "dateModified": "2025-07-28T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Kyle Mapue"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/blog/my-kubernetes-journey/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kyle Mapue",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/images/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Kyle Mapue (Alt + H)">
                <img src="http://localhost:1313/images/coding.png" alt="" aria-label="logo"
                    height="35">Kyle Mapue</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/blog" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/blog/">Blogs</a></div>
    <h1 class="post-title entry-hint-parent">
      Kubernetes Journey: From kubectl to GitOps
    </h1>
    <div class="post-meta"><span title='2025-07-28 00:00:00 +0000 UTC'>July 28, 2025</span>&nbsp;·&nbsp;Kyle Mapue

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">‎ Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#the-log-pong-application" aria-label="The Log-Pong Application">The Log-Pong Application</a></li>
                <li>
                    <a href="#manual-deployment" aria-label="Manual Deployment">Manual Deployment</a></li>
                <li>
                    <a href="#service-connectivity" aria-label="Service Connectivity">Service Connectivity</a></li>
                <li>
                    <a href="#gitops-automation" aria-label="GitOps Automation">GitOps Automation</a></li>
                <li>
                    <a href="#reliability-enhancements" aria-label="Reliability Enhancements">Reliability Enhancements</a></li>
                <li>
                    <a href="#conclusion-the-journey-is-the-destination" aria-label="Conclusion: The Journey is the Destination">Conclusion: The Journey is the Destination</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h3>
<p>For anyone diving into DevOps, there&rsquo;s a moment when the theory of Kubernetes—all the talk of Pods, Services, and Deployments—needs to meet the messy reality of practice. My journey with the &ldquo;Log-Pong&rdquo; application was exactly that: a hands-on, often challenging, but ultimately rewarding experience that took me from manually managing resources to orchestrating a fully automated GitOps pipeline.</p>
<p>This post isn&rsquo;t just a project showcase. It&rsquo;s a story about the power of starting with the fundamentals, embracing the &ldquo;manual&rdquo; way to build deep understanding, and then leveraging that knowledge to build a professional, automated workflow. If you&rsquo;re on a similar path, I hope my story resonates and offers some useful insights.</p>
<h3 id="the-log-pong-application">The Log-Pong Application<a hidden class="anchor" aria-hidden="true" href="#the-log-pong-application">#</a></h3>
<p>Before we dive into the <em>how</em> (the deployment), let&rsquo;s quickly cover the <em>what</em>. The &ldquo;Log-Pong&rdquo; stack consists of two simple microservices designed to demonstrate key Kubernetes concepts:</p>
<ol>
<li>
<p><strong>The <code>pingpong-app</code> (The Backend):</strong></p>
<ul>
<li><strong>What it is:</strong> A stateful backend service.</li>
<li><strong>Technology:</strong> Node.js with the Koa framework, connected to a PostgreSQL database.</li>
<li><strong>What it does:</strong> Its only job is to expose an API endpoint (<code>/ping</code>). When called, it increments a counter in the database and returns the new number of &ldquo;pongs.&rdquo; This service represents a stateful component whose data must persist.</li>
</ul>
</li>
<li>
<p><strong>The <code>log-output-app</code> (The Frontend/Aggregator):</strong></p>
<ul>
<li><strong>What it is:</strong> A frontend service that gathers information from various sources.</li>
<li><strong>Technology:</strong> Node.js with Koa, running in a unique two-container Pod.</li>
<li><strong>What it does:</strong>
<ul>
<li>A <strong>writer</strong> container continuously writes the current timestamp to a shared file.</li>
<li>A <strong>reader</strong> container waits for requests. When a request comes in, it reads the timestamp from the shared file, fetches a message from a Kubernetes ConfigMap, and makes an HTTP call to the <code>pingpong-app</code> to get the current pong count. It then combines all this information into a single string.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>How They Work Together:</strong> The user interacts with the <code>log-output-app</code>, which in turn communicates with the <code>pingpong-app</code> over the cluster&rsquo;s internal network. The final output looks something like this:</p>
<pre tabindex="0"><code>file content: this text is from file
env variable: MESSAGE=hello world
2025-07-21T10:30:00.123Z: a1b2c3d4e5f6...
Ping / Pongs: 42
</code></pre><p>It&rsquo;s a simple system, but its architecture is perfect for exploring the core concepts of Kubernetes networking, state management, and configuration. Now, let&rsquo;s get into how it was deployed.</p>
<h3 id="manual-deployment">Manual Deployment<a hidden class="anchor" aria-hidden="true" href="#manual-deployment">#</a></h3>
<p>Every project starts somewhere. Mine began with the two applications described above. Initially, getting them to run was a manual process of building Docker images and applying Kubernetes manifests one by one.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 1. Build the image</span>
</span></span><span style="display:flex;"><span>docker build -t my-username/pingpong-app .
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. Push it to a registry</span>
</span></span><span style="display:flex;"><span>docker push my-username/pingpong-app
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. Deploy it to the cluster</span>
</span></span><span style="display:flex;"><span>kubectl apply -f manifests/deployment.yaml
</span></span><span style="display:flex;"><span>kubectl apply -f manifests/service.yaml
</span></span></code></pre></div><p>I had to do this for both applications. It was tedious, but it was also the perfect way to learn the fundamentals. I wasn&rsquo;t just running a script; I was forced to understand what each <code>kubectl apply</code> command was actually doing. What&rsquo;s a <code>Deployment</code>? Why does it need a <code>Service</code>? How do labels and selectors work? This manual phase was my classroom.</p>
<p><img alt="kubectl get pods,svc output" loading="lazy" src="/blog/my-kubernetes-journey/kubectl-get-pods-svc.png"></p>
<h3 id="service-connectivity">Service Connectivity<a hidden class="anchor" aria-hidden="true" href="#service-connectivity">#</a></h3>
<p>Running the apps was one thing; making them talk to each other was a whole new challenge. This is where the real learning began.</p>
<p>My first attempt involved the shared volume between the &ldquo;writer&rdquo; and &ldquo;reader&rdquo; containers, but the real breakthrough came when I truly understood Kubernetes <strong>Services</strong>. By giving my <code>pingpong</code> deployment a <code>ClusterIP</code> service, it received a stable DNS name inside the cluster.</p>
<p>Suddenly, my <code>log-output</code> app could reliably find and talk to it over the network.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// In the log-output reader&#39;s code
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">PINGPONG_URL</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;http://pingpong-svc:3001/ping&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pingResponse</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">axios</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">PINGPONG_URL</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pingCount</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">pingResponse</span>.<span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">pong</span>;
</span></span></code></pre></div><p>This was a huge &ldquo;aha!&rdquo; moment. I had moved from a shared-filesystem model to true service-to-service communication, the foundation of microservice architecture.</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">      graph TD
          ExternalUser[External User] --&gt; KubernetesIngress(Kubernetes Ingress\n(e.g., /log-output))
          KubernetesIngress --&gt; ServiceLogOutput(Service: log-output\n(Type: ClusterIP))
          ServiceLogOutput --&gt; PodLogOutput(Pod: log-output\n\n  - Reader Container\n  - Writer Container)
          ServiceLogOutput --&gt; ServicePingpong(Service: pingpong\n(Type: ClusterIP))
          PodLogOutput --&gt; ServicePingpong
          ServicePingpong --&gt; PodPingpong(Pod: pingpong\n\n  - Koa App Container)
</code></pre><p>It&rsquo;s a simple system, but its architecture is perfect for exploring the core concepts of Kubernetes networking, state management, and configuration. Now, let&rsquo;s get into how it was deployed.</p>
<h3 id="gitops-automation">GitOps Automation<a hidden class="anchor" aria-hidden="true" href="#gitops-automation">#</a></h3>
<p>The manual workflow had taught me a lot, but it was slow and error-prone. It was time to automate. I decided to refactor the entire project into a professional GitOps workflow using <strong>ArgoCD</strong>.</p>
<p>This meant a fundamental change in structure:</p>
<ol>
<li><strong><code>pingpong-code</code> Repo</strong>: Contained only the application source code.</li>
<li><strong><code>log-output-code</code> Repo</strong>: Contained only its application source code.</li>
<li><strong><code>log-pong-config</code> Repo</strong>: Contained <em>only</em> the Kubernetes YAML manifests. This became my single source of truth.</li>
</ol>
<p>Next, I built a <strong>CI/CD pipeline</strong> with GitHub Actions for each application repository. On every push to <code>main</code>, the pipeline would:</p>
<ol>
<li>Build a new Docker image and tag it with the commit SHA.</li>
<li>Push the image to Docker Hub.</li>
<li>Check out the <code>log-pong-config</code> repository.</li>
<li><strong>Automatically update the <code>image:</code> tag</strong> in the deployment manifest.</li>
<li>Commit and push the change to the config repo.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#75715e"># A snippet from the GitHub Actions workflow</span>
</span></span><span style="display:flex;"><span>- <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Update Image Tag</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">run</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    sed -i &#39;s|image: .*|image: ${{ secrets.DOCKERHUB_USERNAME }}/pingpong-app:${{ github.sha }}|g&#39; log-pong-config/manifests/rollout.yaml</span>
</span></span></code></pre></div><p>The final piece was <strong>ArgoCD</strong>. I pointed it at my <code>log-pong-config</code> repository. Now, whenever the CI pipeline pushed an updated image tag, ArgoCD would detect the change and automatically sync it with my cluster. My job was done. I had created a fully automated, end-to-end deployment pipeline.</p>
<p><img alt="ArgoCD UI showing Healthy and Synced - Part 1" loading="lazy" src="/blog/my-kubernetes-journey/blog_ping1.png"></p>
<p><img alt="ArgoCD UI showing Healthy and Synced - Part 2" loading="lazy" src="/blog/my-kubernetes-journey/blog_ping2.png"></p>
<p><img alt="ArgoCD UI showing Healthy and Synced - Part 3" loading="lazy" src="/blog/my-kubernetes-journey/blog_ping3.png"></p>
<h3 id="reliability-enhancements">Reliability Enhancements<a hidden class="anchor" aria-hidden="true" href="#reliability-enhancements">#</a></h3>
<p>With the core workflow in place, I added two more features to make the system truly robust.</p>
<ol>
<li>
<p><strong>Readiness Probes</strong>: The <code>pingpong</code> app is useless without its database. I configured a <code>readinessProbe</code> that hits a <code>/healthz</code> endpoint. This endpoint only returns a <code>200 OK</code> if the database connection is active. Now, Kubernetes won&rsquo;t send traffic to a <code>pingpong</code> pod until it&rsquo;s confirmed it can do its job.</p>
<p><img alt="kubectl describe pod events" loading="lazy" src="/blog/my-kubernetes-journey/kubectl-describe-pod-events.png"></p>
<p>To prove this, I simulated a database failure by deleting its <code>StatefulSet</code>. When the <code>pingpong</code> pod tried to restart, it couldn&rsquo;t connect. Running <code>kubectl describe pod</code> on the new pod revealed exactly what was happening in the events log:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Status:           Running
</span></span><span style="display:flex;"><span>IP:               10.68.2.70
</span></span><span style="display:flex;"><span>Ready:            False
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>Events:
</span></span><span style="display:flex;"><span>  Type     Reason     Age   From     Message
</span></span><span style="display:flex;"><span>  ----     ------     ----  ----     -------
</span></span><span style="display:flex;"><span>  Normal   Scheduled  15s   scheduler  Successfully assigned default/pingpong-rollout...
</span></span><span style="display:flex;"><span>  Normal   Pulled     15s   kubelet    Container image &#34;kylmps/pingpong:5&#34; already present...
</span></span><span style="display:flex;"><span>  Normal   Created    15s   kubelet    Created container pingpong
</span></span><span style="display:flex;"><span>  Normal   Started    15s   kubelet    Started container pingpong
</span></span><span style="display:flex;"><span>  Warning  Unhealthy  4s    kubelet    Readiness probe failed: HTTP probe failed with statuscode: 500
</span></span></code></pre></div><p>The probe was working perfectly, preventing the broken pod from receiving traffic and protecting the system from cascading failures.</p>
</li>
<li>
<p><strong>Canary Deployments &amp; Automated Analysis</strong>: To deploy updates safely, I switched from a <code>Deployment</code> to an Argo Rollouts <code>Rollout</code> resource. I configured it to perform canary releases and defined an <code>AnalysisTemplate</code> to monitor CPU usage. If a new version causes a CPU spike, the rollout is automatically aborted and rolled back. No human intervention required.</p>
</li>
</ol>
<h3 id="conclusion-the-journey-is-the-destination">Conclusion: The Journey is the Destination<a hidden class="anchor" aria-hidden="true" href="#conclusion-the-journey-is-the-destination">#</a></h3>
<p>Building the Log-Pong stack taught me more than any tutorial ever could. By starting manually, I was forced to learn the &ldquo;why&rdquo; behind every Kubernetes object. That fundamental knowledge was the bedrock upon which I could confidently build a complex, automated GitOps workflow.</p>
<p>If you&rsquo;re just starting out, embrace the manual steps. Break things. Fix them. Understand the moving parts. Because when you finally automate, you&rsquo;ll be doing it with the confidence of someone who knows exactly what&rsquo;s happening under the hood.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Kyle Mapue</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
